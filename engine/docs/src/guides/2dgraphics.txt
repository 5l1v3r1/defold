2D Graphics
===========

2D games are commonly built by many images that are presented as is (for backgrounds or sprites), used in _flip-book animation_ (for sprites), combined and rigged to create _Spine animation_ (for sprites) or mapped out into tilemaps and used for levels or backgrounds. For performance reasons, these images are often combined into one or a few larger images, but the small original image can still be referenced as a sub-image on the larger one. Combining smaller images into larger is especially important on mobile devices where memory and processing power is more scarce than on desktop machines or dedicated game consoles.

In Defold, there are two types of asset that represent such a larger image:

Atlases :: An _atlas_ contains a list of separate images files, which are automatically combined into a larger image. See http://en.wikipedia.org/wiki/Texture_atlas

Tile Sources :: A tile source references an image file that is already containing sub-images ordered on a uniform grid. Other tools sometimes use the terms _tile set_ and _sprite sheet_ for this type of image. See http://en.wikipedia.org/wiki/Tileset#Tile_set

== Animation support

Defold has built in support for two types of animation that you can use as a source of graphics for object components:

Flip-book animation :: A flip book animation consists of a series of still images that are shown in succession. The technique is very similar to traditional cell animation (see http://en.wikipedia.org/wiki/Traditional_animation). The technique offers limitless opportunities since each frame can be manipulated individually. However, since each frame is stored in a unique image, the memory footprint can be high. The smoothness of animation is also dependent on the number of images shown each second but increasing the number of images usually also increase the amount of work. Defold flip book animations are either stored as individual images added to an Atlas, or as a Tile Source with all frames laid out in a horizontal sequence.

image::images/2dgraphics/2dgraphics_animsheet.png["Animation sheet", align="center"]

Spine animation :: Spine animation, or _skeletal animation_ (see http://en.wikipedia.org/wiki/Skeletal_animation), is a fundamentally different technique that is closer to cutout animation. In cutout animation separate pieces of the animated object (e.g body parts, eyes, mouth etc) are moved individually between each frame. Spine animation let you build an invisible, virtual skeleton consisting of a hierarchy of interconnected _bones_. This skeleton, or _rig_, is then animated and individual images are attached to the bones. Defold supports animations created or exported in the http://esotericsoftware.com/spine-json-format[Spine JSON format].

== Importing Image Files

Defold needs all assets that should be in your project hierarchy. Therefore you should start by importing the image files you want to build your graphics from. To import image assets, simply drag the files from the file system on your computer and drop them in an appropriate place in the Defold editor _Project Explorer_.

[IMPORTANT]
====
Currently, Defold only support the PNG image format.
====

image::images/2dgraphics/2dgraphics_import1.png["Importing image files", align="center"]

image::images/2dgraphics/2dgraphics_import2.png["Importing image files", align="center"]

== Creating an Atlas

You need to populate an _Atlas_ before you can use it. As soon as you have added images and/or animations to the Atlas, it can be used as a graphics source to object components like Sprites and ParticleFX components.

Your atlas has now been populated with images (and animations) it can be used as a graphics source to other components in Defold (see Sprite below and the ParticleFX guide)._

. Import your image files as described above.
. Select *New > Atlas File* from the context menu in the Project Explorer.
. Select *Add Images* from the context menu in the Outline.

A dialog opens from where you can find and select the images you want to add to the Atlas. Note that you can filter the image files and select multiple files at once.

image::images/2dgraphics/2dgraphics_atlas_add.png["Creating an atlas, adding images", align="center"]
image::images/2dgraphics/2dgraphics_atlas.png["Creating an atlas", align="center"]

=== Flip-book animations

You can define flip-book animations of selected sub-images in an atlas:

. Select *Add Animation Group* from the context menu in the Outline.
. Select *Add Images* from the context menu of the created animation group and choose the images that you want as frames of the animation.
. Adjust the *Properties* for the animation as needed.

You can reorder the images in the Outline by dragging them, if needed. You can also easily create duplicates by copying and pasting (From the *Edit* menu, the right click context menu or keyboard shortcuts) images in the outline. Select an animation and press *Space* on your keyboard to preview the animation.

== Creating a Tile Source

To create a Tile Source you need an image containing all the tiles. All tiles must have the exact same dimensions and be placed in a grid. Defold supports _spacing_ between the tiles and _padding_ around each tile. Defold can also automatically _extrude borders_ which is sometimes neccessary to avoid visual artifacts.

Once you have the source image created, you can create a Tile Source:

. Import the image to your project by dragging it into the Project Explorer.
. Create a new Tile Source file.
. Click the browse-button next to the *Image* property and select your image. Now you should see the image displayed in the editor.
. Adjust the *Tile Height*, *Tile Width*, *Tile Margin* and *Tile Spacing* to match the source image. When everything is correctly set you should see the tiles line up perfectly inside each cell of the transparent grid.

image::images/2dgraphics/2dgraphics_tilesource.png["Creating a Tile Source", align="center"]

[NOTE]
====
If you use linear filtering (see below) and a Tile Source where each tile lies immediately next to each other (i.e. has no borders), there is a risk that you will experience a visual artifact called edge bleeding: if a neighboring tile has colored pixels on its edge, their color might bleed over at the edges. The easiest way to fix this problem is to set the *Extrude Border* property (which can be found on Atlases and Tile Sources). The value specifies how many times the edge pixels should be automatically replicated in the final texture used in when the game is run.

A god measure is to specify a number that corresponds to how much you scale the textures when viewed in game. If you display the game world at half scale (you can see 2 times as much) then set *Extrude Borders* to 2. When the texture is used scaled down to half the size, a _mipmap_ is used for rendering. That mipmap is half the width and height of the original image.
====

[[anchorcs]]
=== Collision Shapes

Collision shapes that enable physics interaction with Tile Maps can be automatically generated. Defold uses the alpha channel from the image specified in the *Collision* property to generate a _convex_ shape for each tile. Often it is sensible to use the same image for collision as the one containing the actual graphics, but you are free to specify a separate image if you want collision shapes that differ from the visuals. When you specify a collision image, the preview is updated with an outline on each tile indicating the generated collision shapes. See the link:/doc/physics[Physics documentation] for more details.

image::images/2dgraphics/2dgraphics_tilesource_collision.png["Collision Shapes", align="center"]

=== Flip-book animations

To define an animation in a Tile Source each frame must correspons to one tile (be on a grid of a certain width and height). Each frame tile must lie next to each other in a sequence left to right. The sequence can wrap from one row to the next. All newly created Tile Sources has a default animation named "anim". Selecting it displays the animation *Properties* that allow you to set a descriptive name, start and end frame, playback method and speed and whether the animation should be visually flipped horizontally or vertically.

image::images/2dgraphics/2dgraphics_tilesource_animation.png["Tile Source add animation", align="center"]

You can easily add more animations to the Tile Source by selecting *Add Animation* in the context menu that can be accessed by right clicking the root *Tile Source* in the Outline view.

image::images/2dgraphics/2dgraphics_tilesource_add_animation.png["Tile Source animation", align="center"]

== Game objects and visual components

When you add visual components (Sprites, ParticleFX etc) to a game object, you are able to set the _position_ and _rotation_ of the component. These values are used as offsets against the position and rotation of the game object. And more, the values are _set_ in the component when you assemble the game object.

image::images/2dgraphics/2dgraphics_component_position.png["Component position", align="center"]

Defold game objects can be moved, rotated and have any of its properties animated. Components belonging to a manipulated game object undergo the same manipulations as the game object, but will keep their relative position and rotation as set in the game object. Components can be turned on and off, but are not possible to animate or move or rotate dynamically. Therefore, if you have graphics that you intend to alter you should put the graphics in separate game objects. A group of game objects or a game object hierarchy is conveniently assembled in a Collection. Then you can freely manipulate the objects:

image::images/2dgraphics/2dgraphics_gameobject_position.png["Component position", align="center"]

[source-code]
----
    -- Animate the wand game object to specified position and rotation.
    go.animate("wand", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(530, 79, -0.1), go.EASING_INOUTSINE, 0.5)
    go.animate("wand", "euler", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0, 0, -70), go.EASING_INOUTSINE, 0.5)
----

== Sprites

Sprite components are used to add graphics and flip-book animations to game objects. They are typically used to create characters and props. Creating a Sprite component is very straightforward:

. Create (or open) the game object the Sprite should belong to.
. From the Game Object context menu in the Outline, select *Add Component*.
. Choose "Sprite".
. Specify in the Sprite's *Image* property which Tile Source or Atlas the Sprite should use.
. Specify in the Sprite's *Default Animation* property which animation it should play by default.

The default animation is played when the game object is created in the running game. Note that if you use an Atlas as the image resource you will see still images as well as animations in the *Default Animation* drop down menu. If you want to create a Sprite with a still image out of a Tile Source, you can create a 1 frame animation and set its *Playback* property to "None".

To run different animations during runtime you post +link:/ref/sprite#play_animation[play_animation]+ messages to the Sprite component. As soon as an animation os finished playing, the engine sends back a +link:/ref/sprite#animation_done[animation_done]+ message to the script that sent the +play_animation+ message.

=== Sprite example

Suppose that your game has a "dodge" feature that allows the player to press a specific button to dodge. You have created four animations to support the feature with visual feedback:

"idle" :: A looping animation of the player character idling.
"dodge_idle" :: A looping animation of the player character idling while being in the dodging stance.
"start_dodge" :: A play-once transition animation taking the player character from standing to dodging.
"stop_dodge" :: A play-once transition animation taking the player character from dodging back to standing.

The following script provides the logic:

[source-code]
----
function on_input(self, action_id, action)
    -- "dodge" is our input action
    if action_id == hash("dodge") then
        if action.pressed then
            msg.post("#sprite", "play_animation", {id = hash("start_dodge")})
            -- remember that we are dodging
            self.dodge = true
        elseif action.released then
            msg.post("#sprite", "play_animation", {id = hash("stop_dodge")})
            -- we are not dodging anymore
            self.dodge = false
        end
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("animation_done") then
        -- one of the transition animations are finished, let's start looping
        if self.dodge then
            msg.post("#sprite", "play_animation", {id = hash("dodge_idle")})
        else
            msg.post("#sprite", "play_animation", {id = hash("idle")})
        end
    end
end
----

=== Collision Shapes

Sprites do not yet support Collision Shapes generated in Tile Sources. Instead, you add Collision Objects with Collision Shapes like you would for any game object. See the link:/doc/physics[Physics documentation] for details.

=== Blend Mode

The *Blend Mode* property defines how the sprite should be blended with the graphics behind it. These are the available blend modes and how they are calculated:

Alpha :: Normal blending: a~0~ * rgb~0~ + (1 - a~0~) * rgb~1~

Add :: Brighten the background with the color values of the corresponding sprite pixels: rgb~0~ + rgb~1~

Add Alpha :: Brighten the background with the corresponding visible sprite pixels: a~0~ * rgb~0~ + rgb~1~

Multiply :: Darken the background with values of the the corresponding sprite pixels: rgb~0~ * rgb~1~

=== Sprite Shading

The default sprite shading files are located under "/builtins/material/sprite.*" in your project. The default shading performs a regular texture lookup, but also has a tint (a fragment shader constant) which is multiplied with the texture color.

To obtain effects like flashing a sprite white when it is hit, you can implement custom shading. To set a custom shading for your sprites, follow these steps:

. Copy the files under "/builtins/material/sprite.*" into one of your project directories (you can't modify the content of the "builtins"-directory). This is not mandatory but makes the process easier.
. Open the copied "sprite.material" file and remap the shader files (.vp and .fp) to your own copies.
. Edit the .vp and .fp copies as you please. If you introduce shader constants, they must also be declared in the material file.
. Open your sprite and specify your new material in the Properties.
. To set a shader constants while the game is running, use the functions +link:/ref/sprite#sprite.set_constant[sprite.set_constant()]+ and +link:/ref/sprite#sprite.reset_constant[sprite.reset_contant()]+.

== Tile Maps

A Tile Map is a component that allows you to assemble, or _paint_, tiles from a Tile Source onto a large grid area. Tile Maps are commonly used to build game level environments. You can also use the Collision Shapes from the Tile Source in your maps for collision detection and physics simulation.

=== Painting Tiles

. Open the Tile Map you want to work in.
. Make sure that there are no flagged issues in the Property or Outline view.
. Select or create a Layer to paint on in the Outline view.
. Select a tile to use as brush (press *Space* to show the tile palette)

image::images/2dgraphics/2dgraphics_tilemap.png["Painting tiles", align="center"]

=== Picking Tiles

You can also pick tiles directly from the Tile Map to use as a brush. Hold *Shift* and click a tile to pick it up as the current brush. When holding *Shift* you can also click and drag to select a block of tiles to use as a larger brush.

image::images/2dgraphics/2dgraphics_tiles_pick.png["Picking tiles", align="center"]

=== Erasing Tiles

The Eraser tool is used to erase painted tiles. To select the Eraser, you can either:

. Select it from the Tile Map menu
. Press *Backspace*
. Click the active tile again in the tiles palette
. Pick any empty cell on the Tile Map

=== Attaching Physics

You can attach physics to the Tile Map to do collision detection or physics simulations involving tiles. To attach physics to a Tile Map, see the link:doc/physics[Physics documentation] for details.

== Changing tiles from script

You can change the content of a Tile Map dynamically while your game is running. To do so, send +link:/ref/tilemap#set_tile[set_tile]+ messages to the Tile Map:

[source-code]
----
-- Replace the two door-tiles with "open door" tiles.
-- The door is two tiles on top of each other.
local doorpos = vmath.vector3(174, 305, 0)
msg.post("/level#tilemap", "set_tile", { layer_id = hash("layer1"), position = doorpos, tile = 58 })
-- Upper part of door can be adressed with same position and "dy" set to 1.
msg.post("/level#tilemap", "set_tile", { layer_id = hash("layer1"), position = doorpos, tile = 46, dy = 1 })
----

== Texture Filtering and Sampling

Defold supports two different ways to do texture sampling. The method governs the visual result in cases when a _texel_ (a pixel in a texture) is not perfectly aligned with a screen pixel--. This happens when you move a Sprite containing the texture seamlessly (say 0.2 pixels in any direction), if your camera is moving seamlessly or if your camera zooms in or out:

Nearest :: The nearest texel will be picked to color the screen pixel. This sampling method should be chosen if you want a perfect one-to-one pixel mapping from your textures to what you see on screen. With nearest filtering everything will snap from pixel to pixel when moving which looks twitchy if the Sprite moves slowly.

Linear :: The texel will be averaged with its neighbors before coloring the screen pixel. This produces smooth appearances for slow, continuous motions as a Sprite will bleed into the pixels before fully coloring them--it is this possible to move a Sprite less than a whole pixel.

The setting for which filtering to use is stored in the link:/doc/game_project[Project Settings] file. There are two settings:

default_texture_min_filter :: Minifying filtering applies whenever the texel is smaller than the screen pixel.
default_texture_mag_filter :: Magnifying filtering applies whenever the texel is larger than the screen pixel.

Both settings accept the values _linear_ or _nearest_. For example:

[source-code]
----
[graphics]
default_texture_min_filter = nearest
default_texture_mag_filter = nearest
----
If you don’t specify anything, both are set to _linear_ by default.

