Scripting
=========

All application and game logic in your Defold project is controlled through _script_. The Defold engine has the Lua language embedded for scripting. Lua is a lightweight dynamic language that is very powerful. It is widely used as a videogame scripting language. Lua implements a rather small set of advanced features such as:

* First-class functions
* Garbage collection
* Closures
* Proper http://www.lua.org/pil/6.3.html[tail calls]
* Coercion (automatic conversion between string and number values at run time)
* Coroutines (cooperative multitasking)
* Dynamic link:doc/modules[module loading].

Lua also comes with a limited set of data types. (See http://lua-users.org/wiki/LuaTypesTutorial):

* Numbers (+10+, +3.141592653+, +2-7+, +7/8+)
* Strings (+"This is a string"+)
* Booleans (+true+, +false+)
* Tables (+{}+, +{"a", "b", "c"}+) See http://lua-users.org/wiki/TablesTutorial.
* Functions (+function myfunc() ... end+, +function (x) ... end+)
* +nil+ values
* Userdata (See below)

Lua is quite easy to learn if you have some experience with other languages like C, Python or Javascript. There is extensive documentation on the language online (check out http://www.lua.org) and there are several good books. In particular http://www.lua.org/pil/[Programming in Lua] by Roberto Ierusalimschy, the leading architect of the language.

== Script types

There are three types of script in Defold, each type written in the Lua language but with different libraries available.

Logic scripts :: Extension _.script_. Run by script components in game objects. Logic scripts are usually used to control game objects and the logic that binds the game together with level loading, game rules and so forth. Logic scripts has access to all Defold library functions except link:/ref/gui[GUI] and link:/ref/render[Render] functions.

GUI scripts :: Extension _.guiscript_. Run by GUI components and usually contains the logic required to display GUI elements like heads up displays, menus etc. GUI scripts has access to the link:/ref/gui[GUI] library functions.

Render scripts :: Extension _.renderscript_. Run by the rendering pipeline and contains the logic required to render all app/game graphics each frame. Render scripts has access to the link:/ref/render[Render] library functions.

== Editor support

The Defold editor supports Lua script editing with syntax coloring and auto-completion. To fill out function names, press *Ctrl+Space* to bring up a list of the functions matching what you are typing.

image::images/scripting/scripting_completion.png["Auto completion", align="center"] 

== Message passing and shared data

When designing any software system or application it is generally best to couple all objects, modules or components http://en.wikipedia.org/wiki/Loose_coupling[as loosely as possible]. Any object that creates dependencies to the inner workings of another object is considered to be _tightly coupled_ and such coupling often lead to code that is harder to maintain. Since tight coupling increases the dependencies between sections of code and one object might modify another object’s internals, it is a common source of bugs--some of which can be very hard to track down.

Lua is not object oriented in the sense that you define your application by setting up a class hierarchy with inheritance (like Java, C++ or C#). Instead, Defold extends Lua with a simple and powerful object oriented design with the following characteristics:

* link:/doc/message_passing[Message passing] to communicate between objects
* Local retention and protection and hiding of state-process
* Extreme late-binding (i.e. you can send any message to any object. The response to a message is fully decided in the runtime of the receiving object)

Through a solid underlying message dispatch mechanism you are encouraged to create game objects with totally encapsulated functionality, state that is managed internaly by the object and communication between objects through message passing. Adhering to this paradigm when designing a game or application can sometimes be hard. It requires careful design consideration but often results in code that is robust and maintainable.

It is, however, possible to deliberately sidestep Defold’s message passing. Lua is a powerful dynamic environment and it gives you great freedom. You can, for instance, easily couple game objects very strongly to each other by controlling them through shared state variables that you read and set directly from other game objects.

Lua modules provide powerful means to build reusable code that can easily be shared between objects--in a project or between different projects. When creating a module, it is important to take great care and consider how the module fits into the loosely coupled nature of Defold.

== Lua contexts

When Defold reads and executes code, this happens within a ‘Lua context’: everything that exists in the same context shares the same data and sees the same things. This means that if a script file that is evaluated in a context defines a function, that function is also available from other script files that are evaluated in the same context--automatically.

For each top level collection, Defold evaluates Lua code in two separate contexts: one for game object script components and one for GUI scripts. If you dynamically load a new collection into the engine (through a link:/doc/collection_proxies[collection proxy]) that collection’s scripts will be evaluated in two new separate Lua contexts:

image::images/scripting/scripting_contexts.png["Contexts", align="center"] 

== Reactive logic

A game object with a script component implements some logic. Often, that logic is dependent on some external factor. An enemy AI might react to the player being within a certain radius from the AI; a door might unlock and open as a result of player interaction, etc, etc.

The +update()+ function allows you to implement complex behaviors defined as a state machine running each frame--sometimes that is the adequate approach. But there is a cost associated with each call to +update()+. Unless you really need the function you should delete it and instead try to build your logic _reactively_. It is cheaper to passively wait for some message to trigger a response than it is to actively probe the game world for data to respond to. Furthermore, solving a design problem reactively also often leads to cleaner and more stable design and implementation.

Let's look at a concrete example. Suppose that you want a game object to send a message 2 seconds after it has been initiated. It should then wait for a certain response message and after received the response, it should send another message 5 seconds later. The non reactive code for that would look something like this: 

[source-code]
----
function init(self)
        -- Counter to keep track of time.
        self.counter = 0
        -- We need this to keep track of our state.
        self.state = "first"
end

function update(self, dt)
        self.counter = self.counter + dt
        if self.counter >= 2.0 and self.state == "first" then
                -- send message after 2 seconds
                msg.post("some_object", "some_message")
        end
        if self.counter >= 5.0 and self.state == "second" then
                -- send message 5 seconds after we received "response"
                msg.post("another_object", "another_message")
                -- Nil the state so we don’t reach this state block again.
                self.state = nil
        end        
end

function on_message(self, message_id, message, sender)
        if message_id == hash("response") then
                -- “first” state done. enter next
                self.state = "second"
                -- zero the counter
                self.counter = 0
        end
end
----

Even in this quite simple case we get fairly tangled up logic. It's possible to make this look better with the help of coroutines in a module, but let's instead try to make this reactive and use a built in timing mechanism: property animation:

[source-code]
----
-- Dummy property only for timing
go.property("dummy", 0)
function init(self)
        -- Wait 2s then call send_first()
        go.animate("#", "dummy", go.PLAYBACK_ONCE_FORWARD, 0,
                     go.EASING_LINEAR, 2.0, 0, send_first)
end

function send_first()
        msg.post("some_object", "some_message")
end

function send_second()
        msg.post("another_object", "another_message")
end

function on_message(self, message_id, message, sender)
        if message_id == hash("response") then
                -- Wait 5s then call send_second()
                go.animate("#", "dummy", go.PLAYBACK_ONCE_FORWARD, 0,
                            go.EASING_LINEAR, 5.0, 0, send_second)
        end
end
----

This is cleaner and easier to follow. We get rid of internal state variables that are often hard to follow through the logic--and which might lead to subtle bugs. We also dispose of the +update()+ function completely. That relieves the engine from calling our script 60 times a second, even if it's just idling.

== Debugging

The simplest way to debug your game in Defold is to use http://en.wikipedia.org/wiki/Debugging#Techniques[print debugging]. The technique is simply to use +print()+ or link:/ref/builtins#pprint[pprint()] statements to watch variables or indicate the flow of execution. If a game object without a script acts weird, you can just attach a script to it with the sole purpose of debugging.

Using any of the printing functions will print to the Console view in the Editor. You can also draw text on screen by posting +draw_text+ messages to the +@render+ socket:

[source-code]
----
msg.post("@render:", "draw_text", {text = "My value: " .. my_val, position = vmath.vector3(200, 200, 0)})
----

If you run into problems with spatial calculations, like movement and physics, it is often very helpful to visualize the calculations by drawing lines on the screen. Send +draw_line+ messages to the +@render+ socket:

[source-code]
----
msg.post("@render:", "draw_line", {start_point = my_start, end_point = my_end, color = my_color})
----

Lua comes with a debug library that is useful in some situations, particularly if you need to inspect the innards of your Lua environment. You can find more information about it on http://www.lua.org/pil/contents.html#23.

=== Hot reloading

Defold allows you to perform hot reloading of resources. When developing a game this feature helps speed up certain task enormously. It allows you to change scripts in a game while it is running live. Common use-cases is to tweak gameplay parameters or to perform debugging on a running game.

To reload a changed resource, simply select the menu item *Edit > Reload Resource* or press the corresponding shortcut on the keyboard:

image::images/scripting/scripting_hot_reload.png["Reloading resources", align="center"] 

Every script component can define a +on_reload()+ function. If it exists it will be called anytime a script is reloaded into the game from the editor:

[source-code]
----
function on_reload(self)
    -- Print the current velocity
	print(self.velocity)

    -- Zero the velocity
    self.velocity = vmath.vector3()
end
----

=== Visual profiling

The Defold engine is also able to display profiling information in a running game. This can be helpful when debugging or optimizing.

[source-code]
----
function on_reload(self)
    -- Turn on profiler on hot reload.
	msg.post("@system:", "toggle_profile")
end
----

The profiler displays live information on the running application:

image::images/scripting/scripting_profiling.png["Visual profiler", align="center"] 

== Performance considerations

In a high performance game that is intended to run at a smooth 60 FPS small performance mistakes can have a large impact on the experience. There are some simple general things to consider and some things that might not seem problematic. 

Beginning with the simple things. It is generally a good idea to write code that is straightforward and that does not contain unnecessary loops. Sometimes you do need to iterate over lists of things, but be careful if the list of things is sufficiently large. This example runs in slightly over 1 millisecond on a pretty decent laptop, which can make all the difference if each frame is only 16 milliseconds long (at 60 FPS) and with the engine, render script, physics simulation and so forth eating up a chunk of that.

[source-code]
----
local t = os.clock()
local table = {}
for i=1,2000 do
    table[i] = vmath.vector3(i, i, i)
end
print((os.clock() - t) * 1000)

-- DEBUG:SCRIPT: 1.18
----

Use the value returned from +os.clock()+ (seconds of CPU time for the program) to benchmark suspect code.

=== Memory and garbage collection

Lua's garbage collection runs automatically in the background by default and reclaims memory that the Lua runtime has allocated. Collecting lots of garbage can be a time consuming task so it is good to keep down the number of objects that needs to be garbage collected:

* Local variables are in themselves free and will not generate garbage. (i.e. +local v = 42+) 
* Each _new unique_ string creates a new object. Writing +local s = "some_string"+ will create a new object and assign +s+ to it. The local +s+ itself will not generate garbage, but the string object will. Using the same string multiple times adds no additional memory cost.
* Each time a table constructor is executed (+{ ... }+) a new table is created.
* Executing a _function statement_ creates a closure object. (i.e. executing the statement +function () ... end+, not calling a defined function)
* Vararg functions (+function(v, ...) end+) create a table for the ellipsis each time the function is _called_ (in Lua prior to version 5.2, or if not using LuaJIT).
* +dofile()+ and +dostring()+
* Userdata objects

There are many cases where you can avoid creating new objects and instead reuse the ones you already have. For example. The following is common at the end of each +update()+:

[source-code]
----
-- Reset velocity
self.velocity = vmath.vector3()
----

It's easy to forget that each call to +vmath.vector3()+ creates a new object. Let's find out how much memory one +vector3+ uses:

[source-code]
----
print(collectgarbage("count") * 1024)       -- 41628
local v = vmath.vector3()
print(collectgarbage("count") * 1024)       -- 41678
----

70 bytes has been added between the calls to +collectgarbage()+. Note though that each printing of the result from +collectgarbage()+ builds a string which in itself adds 22 bytes of garbage:

[source-code]
----
print(collectgarbage("count") * 1024)       -- 41326
print(collectgarbage("count") * 1024)       -- 41348
----

So a +vector3+ weighs in at 70-22=48 bytes. That is not much, but if you create _one_ each frame in a 60 FPS game it's suddenly 2.8 kB of garbage per second. With 360 script components that each create one +vector3+ every frame we're looking at 1 MB of garbage generated per second. The numbers can add upp very quickly. When the Lua runtime collects garbage it may eat up many precious milliseconds--especially on mobile platforms.

So, to reset a +vector3+ we can instead use the following construct to avoid creating unnecessary garbage:

[source-code]
----
-- Reset velocity
self.velocity.x = 0
self.velocity.y = 0
self.velocity.z = 0
----

The default garbage collecting scheme may not be optimal for some time critical applications. If you see stutter in your game or app, you might want to tune how Lua collects garbage through the http://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage[collectgarbage()] Lua function. You can, for instance, run the collector for a short time every frame with a low "step" value. To get an idea how much memory your game or app is eating, you can print the current amount of garbage bytes with:

[source-code]
----
print(collectgarbage("count") * 1024)
----

=== Defold userdata

Defold uses Lua _Userdata_ objects to store the following types of data:

* Hash values (link:/ref/builtins#hash[hash])
* URL objects (link:/ref/ref/msg#msg.url[url])
* Math objects (link:/ref/vmath#vmath.vector3[vector3], link:/ref/vmath#vmath.vector4[vector4], link:/ref/vmath#vmath.matrix4[matrix4], link:/ref/vmath#vmath.quat[quaternion])
* Game objects
* GUI nodes 

== Best practices

A common implementation design consideration is how to structure code for shared behaviors. Several possible approaches are possible.

=== Behaviors in a module

image::images/scripting/scripting_module.png["Module", align="center"]

Encapsulating a behavior in a module allows you to easily share code between different game objects’ script components (and GUI scripts). When writing module functions it is generally best to write strictly functional code. There are cases where stored state or side effects is a necessity (or leads to cleaner design). If you have to store internal state in the module, be aware that components share Lua contexts. See the link:/doc/modules[Modules documentation] for details.

Also, even if it is possible to have module code directly modify the internals of a game object (by passing "self" to a module function) it is strongly disencouraged to do so since you create very tight coupling.

=== A helper game object with encapsulated behavior

image::images/scripting/scripting_helper.png["Helper", align="center"]

Just like you can contain script code in a Lua module, you can contained it in a game object with a script component. The difference is that if you contain it in a game object and you communicate with it strictly through message passing.

=== Grouping game object with helper behavior object inside a collection

image::images/scripting/scripting_collection.png["Collection", align="center"]

In this design you can create a behavior game object that automatically acts upon another target game object, either by a predefined name (the user has to rename the target game object to match), or through a +go.property()+ URL that points to the target game object.

The benefit with this setup is that you can drop a behavior game object into a collection containing the target object. Zero additional code is needed.

In situations where you need to manage large quantities of game objects, this design is not preferable since the behavior object is duplicated for each instance and each object will cost memory.

