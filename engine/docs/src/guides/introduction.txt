Introduction
============

This introduction to Defold covers the core concepts of Defold, how the editor works and the most important features. The overview presents the editor, concepts and building blocks briefly and links to more thorough documentation where such exists.

== Concepts

Defold is built upon a set of quite simple concepts that are designed and built on the basis of our view on games development. If you are an experienced developer, these concepts should be pretty straightforward to understand, but please take the time to read this overview carefully--some of our concepts are, even though simple, different from how other tools and engines are designed and built.

=== The editor

The Defold editor is a collection of integrated tools that allow you to import, organize, create and manipulate content that you need for your game or app. The editor contains almost all the tools necessary to make your games, except graphics and sound editing.

The editor is structured into a set of panes that provide different views into your data. The view panes are organized like the image below by default, but it is easy to detach and reorganize the views to your likings.

The editor reacts to standard mouse manipulations of objects. You left-click to mark, left-click and drag to region mark. A right-click on an object or in a view brings up a context sensitive pop-up menu with the available operations.

image::images/introduction/introduction_editor.png["The editor", align="center"]

Project Explorer :: The file structure of your project. Here you can see all files and folders that your project consists of. You can create, rename, move and delete files and folders through this view. File manipulations trigger automatic refactoring (refences to the files are updated) that is built into the editor--all to make restructuring of your project as easy as possible.

Changed Files :: Your projects are automatically tracked and versioned by the Git source control system. Any changes you have made to a file is shown in this view. You can revert changes or open a diff-view (text only) of your changes. 

Editors :: The central pane shows one editor per file. Different file types open different editors. Defold provides visual editors for game objects, collections, atlases, tile maps, GUI:s, particles etc and a capable text editor for Lua script files. The "Scene editor" that is used to work with game objects and collections and give tools for moving, resizing and rotating objects as well as zooming and panning through the scene. See the link:/doc/scene_editing[Scene Editor documentation] for details. 

Outline :: The outline pane shows the content of the current editor in a hierarchial tree view. You can add, remove, select and modify objects and components that are in the editor view.

Properties :: The properties pane shows all properties that are associated with the currently selected object or component. Some properties are edited with special purpose editors that are opened in a separate view pane--for instance the link:/doc/particlefx[Particle FX] "Curve Editor".

Console :: The console at the bottom center prints engine diagnostics and error messages and also any custom +print()+ and +pprint()+ debug messages. If your app or game won't start the console is the first thing to check.

The editor can be downloaded from the http://www.defold.com/dashboard[dashboard]. From there you also create new projects and edit the project members. Select *File > Open Project* from the Editor menu to select a project to work on. When you have selected your project, you also need to select a branch to work on (or create one of there aren't any). A branch is like a personal view of your project. To share the content you make with the other members in your project, select *File > Synchronize* in the editor menu. This also updates your own branch with any changes made by other team members.

=== Game objects

Game worlds that you build in Defond consist of game objects. Everything you can see or interact with is a game object: the player character, projectiles, enemies, landscape decorations an GUI interfaces are all game objects. A game object contains a set of _components_ that give the game object presence and functionality.

image::images/introduction/introduction_blueprint.png["Game object blueprint", align="center"]

You can create a game object _in place_ in a collection. That results in a one-of a kind object. You can copy that object but each copy is separate--changing one does not affect the others. This means that if you create 10 copies of a game object and realize that you want to change them all, you will need to edit all 10 instances of the object. Therefore, in place created game objects should be used for objects that you do not intend to make a lot of copies of.

image::images/introduction/introduction_object_inplace.png["Game object in place", align="center"]

However, a game object that is stored _in a file_ works as a blueprint. When you place instances of a file stored game object in a collection each object is placed by _reference_ -- it is a clone based on the blueprint. If you decide you need to change the blueprint, every single placed game object based on that blueprint is instantly updated.

image::images/introduction/introduction_object_file.png["Game object on file", align="center"]

This ability of either create something in place or store it on file as a blueprint is an idea that runs through Defold.

=== Components

Components are used to extend game objects with presence (graphics, sound) and functionality (spawn factories, collisions, scripted behaviors). A component canâ€™t exist by itself but has to reside inside a game object. Components are usually defined _in place_ in the same file as the game object. However, if you want to reuse a component you can store it in a separate file (like you can with game objects) and include it as a refence in any game object file. Some component types (Lua scripts, for instance) has to be placed in a separate component file and then included as reference in your objects.

Note that you _do not_ manipulate components directly--you can move, rotate, scale and animate properties of _game objects_ that in turn contain components. Messages sent to components trigger component specific functionality:

[source-code]
----
    -- Send message to the "sound" component so it will play its sound.
    msg.post("#sound", "play_sound", {delay = 1, gain = 0.5})
    -- Disable the "beam" sprite component so it's not shown.
    msg.post("#beam", "disable")
----

image::images/introduction/introduction_component.png["Component", align="center"]

=== Collections

A collection is a container of game objects that you have placed and put into position. Collections are most commonly used to build game levels but they are very useful whenever you need to reuse groups and/or hierarchies of game objects that belong together.

A simple game or app can be built in the default "main" collection that is automatically loaded by the engine on startup. This collection is usually called "main.collection" but can be changed in the link:/doc/game_project[project settings]. However, collections are a powerful tool that you can use to group game objects that belong together into reusable units, for example an enemy carrying a power-up item. Collections can also contain other collections (then called "sub-collections").

Below is a simple example of a collection containing three game objects:

1. A HUD game object that present scores for two players.
2. Two Flying Saucer game objects, each controlled by a separate player.

The game objects in turn contain components.

image::images/introduction/introduction_collection.png["Collection example", align="center"]

With a more complex setup of collections (with hierarchies of sub-collections) it is important to understand how addressing works. The link:/doc/message_passing[Message passing documentation] gives you the details.

Collections can be dynamically loaded and unloaded in and out of your game or app by using link:/doc/collection_proxies[Collection proxies].

=== Scripts

A script is a component that contains a program that defines game object behaviors. With scripts you can specify the rules of your game, how objects should respond to various interactions (with the player as well as other objects). All scripts are written in the Lua programming language. To be able to work with Defold, you or someone on your team needs to learn how to program in Lua.

To allow communication between objects, Defold extends Lua with link:/doc/message_passing[Message passing]. Defold also provides a library of useful functions.

Lua comes with many great features. Please see the documentation on http://www.lua.org and on the http://lua-users.org/wiki/LuaDirectory[Lua wiki].

The Lua-code required to play an explosion sound from a game object looks like this:

[source-code]
----
msg.post("#explosion", "play_sound")
----

Here, "explosion" is the name of the object's sound component where the script resides. +play_sound+ is a message that sound components respond to. This is a simple example of message passing, which is how components interact. When scripting, no data is shared between scripts or objects. Components (including scripts) only exchange information by passing messages using the function +msg.post()+. Read the link:doc/scripting[Scripting documentation] for more information on Lua scripting in Defold.

=== Messages

Components communicate with each other and other systems through message passing. Components also respond to a set of predefined messages that alter them or trigger specific actions. You send messages to hide graphics, play sounds or nudge physics objects. The engine also uses messages to notify components of events, for instance when physics shapes collide.

The message passing mechanism needs a recipient for each sent message. Therefore, everything in the game has an address, or an URL. Every game object and component has a unique URL which allows any two components in your app or game to send messages to each other.

See the link:/doc/message_passing[Message passing documentation] for an in depth explanation of how message passing works.

=== Factories

All objects that have been placed in a collection will start at the specified position when the collection is loaded into the game. However, it is common that an app or game needs game objects created dynamically, on the fly. For example, a player might fire bullets and each shot should be dynamically spawned and sent off whenever the player presses the trigger. To create game objects dynamically, you use a factory component.

image::images/introduction/introduction_factory.png["Factory", align="center"]

When you add a factory component to a game object you specify what game object file the factory should use as a blueprint for the objects it creates. To trigger the creation of a game object, sent the factory a message:

[source-code]
----
msg.post("#factory", "create", { position = some_position, rotation = some_rotation })
----

Here, "factory" is the name of the factoy component attached to the game object. +create+ is the message that the factory component responds to by creating a new object. The type of object is set in a property in the factory component. The parameters +position+ and +rotation+ specify where the new object should be placed, and how it should be oriented.

== Collaboration

Most games are created as a collaborative effort between two or more people. We believe that the ability to work together is key for a fast development cycle. Collaboration is therefore a cornerstone of the Defold platform.

image::images/introduction/introduction_collaboration.png["Collaboration", align="center"]

When you create a new project, a central repository is automatically created on our servers. During development, the files you create and modify are your personal view of this repository. When you have done some work and is ready to share your changes, just synchronize your personal view with the central repository. The editor uploads your changes, downloads any new changes (from other team members) and helps resolve conflicts if you and someone else has edited the same piece of project data. All changes are recorded and logged so there is a clear history of what has happened in your project. You don't have to worry about backups and you will never need to email files back and forth with your team.

Defold's collaboration tools are built on the popular and extremely powerful distributed verion control system "Git". (If you're interested in Git, you can read more on http://git-scm.com).

== Building blocks

This is a list of all the available building blocks for creating apps and games. They are listed together with the icon used for the type of building block in the Defold editor.

=== Game object

image::images/icons/brick.png["Game object", align="left"]

See above for a description of game objects.

=== Collection

image::images/icons/bricks.png["Collection", align="left"]

See above for a description of collections.

=== Script

image::images/icons/cog.png["Script", align="left"]

See above for a description of scripts.

=== Sound

image::images/icons/sound.png["Sound", align="left"]

The sound component is responsible for playing a specific sound. Currently, Defold supports soundfiles of the type WAV.

=== Collision object

image::images/icons/weight.png["Collision object", align="left"]

Collision objects are components that extend game objects with physical properties (like spatial shape, weight, friction and restitution). These properties govern how the collision object should collide with other collision objects. The most common types of collision objects are kinematic objects, dynamic objects and triggers. A kinematic object gives detailed collision information that you have to manually respond to, a dynamic object is automatically simulated by the physics engine to obey Newtonian laws of physics. Triggers are simple shapes that detect if other shapes have entered or exited the trigger.

=== Factory

image::images/icons/factory.png["Factory", align="left"]

See above for a description of factories.

=== Sprite

image::images/icons/pictures.png["Sprite", align="left"]

A sprite is a component that extends game objects with graphics. It displays an image either from a Tile source or from an Atlas. Sprites have built-in support for flip-book and bone animation. Sprites are usually used for characters and items. See the link:/doc/tiles[2D graphics documentation] for more information.

=== Atlas

image::images/icons/pictures_atlas.png["Atlas", align="left"]

An atlas is a set of separate images that are compiled into a larger sheet for performance and memory reasons. You can store still images or flip-book animated series of images. Atlases are used by Sprite and ParticleFX components to share graphics resources. See the link:/doc/tiles[2D graphics documentation] for more information.

image::images/introduction/introduction_atlas.png["Atlas", align="center"]

=== Tile source

image::images/icons/small_tiles.png["Tile source", align="left"]

A tile source describes a texture that is composed of multiple smaller images, everyone with the same size. The component support flip-book animation. You can define animations over a sequence of images in the tile source. Tile sources can also automatically calculate collision shapes automatically from image data. This is very useful for creating tiled levels that object can collide and interact with. Tile sources are used by Tile map (and Sprite and ParticleFX although Atlases are usually to prefer) components to share graphics resources. See the link:/doc/tiles[2D graphics documentation] for more information.

image::images/introduction/introduction_tilesource.png["Tile source", align="center"]

image::images/introduction/introduction_tilesource_animation.png["Tile source animation", align="center"]

image::images/introduction/introduction_tilesource_hull.png["Tile source shape", align="center"]

=== Tile map

image::images/icons/layer_grid.png["Tile map", align="left"]

Tile map components display images from a tile source in one or more overlaid grids. They are most commonly used to build game environments: ground, walls, buildings and obstacles. A tile map can display several layers aligned on top of each other with specified blend mode. This is useful to, for example, put foilage on top of grass background tiles. It is also possible to dynamically change the displayed image in a tile. That allows you to, for instance, destroy a bridge and make it impassable by simply replacing the tiles with ones depicting the broken down bridge and containing the corresponding physics shape.

image::images/introduction/introduction_tilemap.png["Tile map", align="center"]

image::images/introduction/introduction_tilemap_palette.png["Tile map palette", align="center"]

=== ParticleFX

image::images/icons/clouds.png["ParticleFX", align="left"]

Particles are very useful for creating nice visual effects, particularly in games. you can use them to create fog, smoke, fire, rain or falling leaves. Defold contains a powerful particle effects editor that allows you to build and tweak effects while you run them real time in your game. The link:/doc/particlefx[ParticleFX documentation] gives you the details on how that works.

image::images/introduction/introduction_particlefx.png["ParticleFX", align="center"]

=== GUI

image::images/icons/text_allcaps.png["GUI", align="left"]

A GUI component contains elements used to construct user interfaces: text and colored and/or textured blocks. Elements can be organized into hierarchial structures, scripted and animated. GUI components are typically used to create heads-up displays, menu systems and on-screen notifications. GUI components are controlled with GUI scripts that defines the behavior of the GUI and controls the user interaction with it. Read more in the link:/doc/gui[GUI documentation].

image::images/introduction/introduction_gui.png["GUI", align="center"]

=== GUI script

image::images/icons/cog.png["GUI script", align="left"]

GUI scripts are used to define the behaviour of GUI components. They control GUI animations and how the user interacts with the GUI.

=== Font

image::images/icons/font.png["Font", align="left"]

A Font is built from a TrueType or OpenType font file. The Font specifies which size to render the font in and what type of decoration (outline and shadow) the rendered font should have. Fonts are used by GUI components.

image::images/introduction/introduction_font.png["GUI", align="center"]

=== Input binding

image::images/icons/keyboard.png["Input binding", align="left"]

Input binding files define how the game should interpret hardware input (mouse, keyboard, touchscreen and game pads). The file bind hardware input to high level input _actions_ like "jump" and "move_forward". In script components that listens to input you are then able to script the actions the game or app should take given certain input. See the link:/doc/input[Input documentation] for details.

image::images/introduction/introduction_input_binding.png["Input binding", align="center"]

=== Camera

image::images/icons/camera.png["Camera", align="left"]

Camera components helps to decide what part of the game world should be visible and how it should be projected. A common use case is to attach a camera to the player game object, or having a separate game object with a camera that follows the player around with some smoothing algorithm.

=== Material

image::images/icons/large_tiles.png["Material", align="left"]

Materials define how different objects should be rendered by specifying shaders and their properties.

=== Render

image::images/icons/paintcan.png["Render", align="left"]

Render files contains settings used when rendering the game to the screen. Render files define which Render script to use for rendering and which materials to use.

=== Render script

image::images/icons/cog.png["Render script", align="left"]

A Render script is a Lua script that controls how the game or app should be rendered to the screen. There is a default Render script that covers most common cases, but you can write your own if you need custom lighting models and other effects.

=== Collection proxy

image::images/icons/bricks_proxy.png["Collection proxy", align="left"]

A Collection proxy is used to load and enable collections on the fly while an app or game is running. The most common use case for Collection proxies are to load levels as they are to be played. See the link:/doc/collection_proxies[Collection proxies documentation] for details. 
